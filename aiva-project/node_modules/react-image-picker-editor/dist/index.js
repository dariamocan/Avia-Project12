function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var Remove = "Quitar";
var Quality = "Calidad";
var Format = "Formato";
var Crop = "Recortar";
var Save = "Guardar";
var Contrast = "Contraste";
var Blur = "Blur";
var Brightness = "Brillo";
var Grayscale = "Scala de gris";
var Saturate = "Saturación";
var Sepia = "Sepia";
var Rotate = "Rotar";
var Undo = "Deshacer";
var labelEs = {
	"Upload a image": "Suba una imagen",
	"You must edit the image in order to resize it": "Debe editar la imagen para disminuir su tamaño",
	"too large": "muy grande",
	"Open the editor panel": "Abra el panel de edición",
	"Download the image": "Descarge la imagen",
	"Control Panel": "Panel de control",
	Remove: Remove,
	Quality: Quality,
	"Max dimensions": "Dimensiones",
	"aspect-ratio": "relación-aspecto",
	"max-width(px)": "max. ancho",
	"max-height(px)": "max. alto",
	Format: Format,
	Crop: Crop,
	"width(px)": "ancho(px)",
	"height(px)": "altura(px)",
	Save: Save,
	Contrast: Contrast,
	Blur: Blur,
	Brightness: Brightness,
	Grayscale: Grayscale,
	Saturate: Saturate,
	Sepia: Sepia,
	Rotate: Rotate,
	Undo: Undo
};

var Quality$1 = "Quality";
var Format$1 = "Format";
var Crop$1 = "Crop";
var Remove$1 = "Remove";
var Save$1 = "Save";
var Contrast$1 = "Contrast";
var Blur$1 = "Blur";
var Brightness$1 = "Brightness";
var Grayscale$1 = "Grayscale";
var Saturate$1 = "Saturate";
var Sepia$1 = "Sepia";
var Rotate$1 = "Rotate";
var Undo$1 = "Undo";
var labelEn = {
	"Upload a image": "Upload a image",
	"You must edit the image in order to resize it": "You must edit the image in order to resize it",
	"too large": "too large",
	"Open the editor panel": "Open the editor panel",
	"Download the image": "Download the image",
	"Control Panel": "Control Panel",
	Quality: Quality$1,
	"Max dimensions": "Max dimensions",
	"aspect-ratio": "aspect-ratio",
	"max-width(px)": "max-width(px)",
	"max-height(px)": "max-height(px)",
	Format: Format$1,
	Crop: Crop$1,
	"width(px)": "width(px)",
	"height(px)": "height(px)",
	Remove: Remove$1,
	Save: Save$1,
	Contrast: Contrast$1,
	Blur: Blur$1,
	Brightness: Brightness$1,
	Grayscale: Grayscale$1,
	Saturate: Saturate$1,
	Sepia: Sepia$1,
	Rotate: Rotate$1,
	Undo: Undo$1
};

var Remove$2 = "Supprimer";
var Quality$2 = "Qualité";
var Format$2 = "Format";
var Crop$2 = "Recadrer";
var Save$2 = "Sauvez";
var Contrast$2 = "Contraste";
var Blur$2 = "Blur";
var Brightness$2 = "Luminosité";
var Grayscale$2 = "Grayscale";
var Saturate$2 = "Saturer";
var Sepia$2 = "Seiche";
var Undo$2 = "Annuler";
var labelFr = {
	"Upload a image": "Charger une image",
	"You must edit the image in order to resize it": "Vous devez éditer l'image pour changer sa taille",
	"too large": "Trop grande",
	"Open the editor panel": "Ouvrir le panneau d'édition",
	"Download the image": "Télécharger l'image",
	"Control Panel": "Panneau de commande",
	Remove: Remove$2,
	Quality: Quality$2,
	"Max dimensions": "Dimensions maximales",
	"aspect-ratio": "rapport de forme",
	"max-width(px)": "largeur max.",
	"max-height(px)": "hauteur max",
	Format: Format$2,
	Crop: Crop$2,
	"width(px)": "largeur(px)",
	"height(px)": "hauteur(px)",
	Save: Save$2,
	Contrast: Contrast$2,
	Blur: Blur$2,
	Brightness: Brightness$2,
	Grayscale: Grayscale$2,
	Saturate: Saturate$2,
	Sepia: Sepia$2,
	Undo: Undo$2
};

var Quality$3 = "Qualität";
var Format$3 = "Format";
var Crop$3 = "Zuschneiden";
var Remove$3 = "Entfernen";
var Save$3 = "Speichern";
var Contrast$3 = "Kontrast";
var Blur$3 = "Blur";
var Brightness$3 = "Helligkeit";
var Grayscale$3 = "Graustufen";
var Saturer = "Sättigen";
var Sepia$3 = "Tintenfisch";
var Undo$3 = "Undo";
var labelDe = {
	"Upload a image": "Bild hochladen",
	"You must edit the image in order to resize it": "Sie müssen das Bild bearbeiten, um seine Größe zu ändern",
	"too large": "zu groß",
	"Open the editor panel": "Editor-Fenster öffnen",
	"Download the image": "Bild herunterladen",
	"Control Panel": "Bedienfeld",
	Quality: Quality$3,
	"Max dimensions": "Maximale Größe",
	"aspect-ratio": "Seitenverhältnis",
	"max-width(px)": "Max. Breite(px)",
	"max-height(px)": "Max. Höhe(px)",
	Format: Format$3,
	Crop: Crop$3,
	"width(px)": "Breite(px)",
	"height(px)": "Höhe(px)",
	Remove: Remove$3,
	Save: Save$3,
	Contrast: Contrast$3,
	Blur: Blur$3,
	Brightness: Brightness$3,
	Grayscale: Grayscale$3,
	Saturer: Saturer,
	Sepia: Sepia$3,
	Undo: Undo$3
};

var MAX_BUFFER_UNDO_MEMORY = 25;
var convertImageUsingCanvas = function convertImageUsingCanvas(dataSrc, changeHeight, state, options) {
  if (changeHeight === void 0) {
    changeHeight = false;
  }

  return new Promise(function (resolve, _) {
    try {
      var img = document.createElement('img');
      img.src = dataSrc + '';
      img.crossOrigin = 'Anonymous';
      var quality = state.quality / 100;
      var maintainRatio = state.maintainAspectRatio;

      img.onload = function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var ratio = img.width / img.height;
        var width = state.maxWidth;
        var height = state.maxHeight;

        if (options !== null && options !== void 0 && options.getDimFromImage) {
          width = img.width;
          height = img.height;
        }

        if (maintainRatio) {
          canvas.width = width;
          canvas.height = width / ratio;

          if (changeHeight) {
            canvas.width = height * ratio;
            canvas.height = height;
          }
        } else {
          canvas.width = width;
          canvas.height = height;
        }

        if (state.basicFilters) {
          ctx.filter = processFilter(state.basicFilters);
        }

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        var type = state.format;
        var dataURI = canvas.toDataURL("image/" + type, quality);
        resolve({
          dataUri: dataURI,
          width: canvas.width,
          height: canvas.height
        });
      };

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }).then(function (data) {
    state.maxHeight = data.height;
    state.maxWidth = data.width;
    return {
      imageUri: data.dataUri,
      state: saveState(state, data.dataUri)
    };
  });

  function processFilter(data) {
    return Object.keys(data).map(function (key) {
      if (['blur'].includes(key)) {
        return key + "(" + data[key] + "px)";
      } else {
        return key + "(" + data[key] + ")";
      }
    }).join('');
  }
};
var saveState = function saveState(state, lastImage) {
  if (state.arrayCopiedImages.length <= MAX_BUFFER_UNDO_MEMORY) {
    state.arrayCopiedImages.push({
      lastImage: lastImage,
      width: state.maxWidth,
      height: state.maxHeight,
      quality: state.quality,
      format: state.format,
      originImageSrc: state.originImageSrc,
      basicFilters: state.basicFilters
    });
  } else {
    state.arrayCopiedImages[state.arrayCopiedImages.length - 1] = {
      lastImage: lastImage,
      width: state.maxWidth,
      height: state.maxHeight,
      quality: state.quality,
      format: state.format,
      originImageSrc: state.originImageSrc,
      basicFilters: state.basicFilters
    };
  }

  return JSON.parse(JSON.stringify(state));
};

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var TabContainer = React.memo(function (_ref) {
  var _ref$activeIndex = _ref.activeIndex,
      activeIndex = _ref$activeIndex === void 0 ? 0 : _ref$activeIndex,
      children = _ref.children,
      _ref$backgroundColor = _ref.backgroundColor,
      backgroundColor = _ref$backgroundColor === void 0 ? 'inherit' : _ref$backgroundColor,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? '#428CFF' : _ref$color,
      _ref$indicatorStyle = _ref.indicatorStyle,
      indicatorStyle = _ref$indicatorStyle === void 0 ? 'bottomLine' : _ref$indicatorStyle,
      _ref$onTabChange = _ref.onTabChange,
      onTabChange = _ref$onTabChange === void 0 ? function (index) {} : _ref$onTabChange,
      _ref$transitionMs = _ref.transitionMs,
      transitionMs = _ref$transitionMs === void 0 ? 375 : _ref$transitionMs,
      _ref$borderLine = _ref.borderLine,
      borderLine = _ref$borderLine === void 0 ? false : _ref$borderLine,
      _ref$fontColor = _ref.fontColor,
      fontColor = _ref$fontColor === void 0 ? 'inherit' : _ref$fontColor,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy;

  var _useState = React.useState([]),
      header = _useState[0],
      setHeader = _useState[1];

  var _useState2 = React.useState(activeIndex),
      activeTab = _useState2[0],
      setActiveTab = _useState2[1];

  var tabContainerRef = React.useRef(null);
  React.useEffect(function () {
    var tabsItems = children instanceof Array ? children : [children];
    checkChildrens(tabsItems);
    var tabs = tabsItems.map(function (el) {
      return {
        label: el.props.name,
        icon: el.props.icon,
        disabled: el.props.disabled
      };
    });
    if (activeIndex > tabs.length - 1 || activeIndex < 0) throw new Error("Invalid range for activeIndex " + activeIndex);
    setHeader(tabs);
  }, [children]);
  React.useEffect(function () {
    var _tabsItems$activeInde, _tabsItems$activeInde2;

    var tabsItems = children instanceof Array ? children : [children];
    if (activeIndex > tabsItems.length - 1 || activeIndex < 0) throw new Error("Invalid range for activeIndex " + activeIndex);
    setActiveTab((_tabsItems$activeInde = tabsItems[activeIndex]) !== null && _tabsItems$activeInde !== void 0 && (_tabsItems$activeInde2 = _tabsItems$activeInde.props) !== null && _tabsItems$activeInde2 !== void 0 && _tabsItems$activeInde2.disabled ? 0 : activeIndex);
  }, [activeIndex]);
  React.useEffect(function () {
    if (header && header.length) {
      onTabChange(activeTab);
    }
  }, [activeTab]);

  function checkChildrens(data) {
    try {
      data.map(function (el) {
        if (!el.props.name) throw new Error('Inside of TabContainer component only can be rendered TabItem component, and its need a name prop');
        return true;
      });
    } catch (e) {
      throw new Error("The TabContainer Component must has a TabItem as child component");
    }
  }

  var tabsItems = children instanceof Array ? children : [children];
  return React__default.createElement("div", {
    ref: tabContainerRef,
    className: "tab-pp"
  }, React__default.createElement("div", {
    className: "header",
    style: {
      backgroundColor: backgroundColor,
      borderBottom: borderLine ? '1px solid #323232' : 'undet'
    }
  }, header.map(function (el, index) {
    return React__default.createElement("button", {
      onClick: function onClick() {
        if (el.disabled) return;
        setActiveTab(index);
      },
      key: el.label,
      style: {
        color: index == activeTab && (indicatorStyle === 'simple' || indicatorStyle === 'bottomLine') ? color : fontColor,
        backgroundColor: index == activeTab && indicatorStyle === 'button' ? color : 'inherit'
      },
      className: index == activeTab ? "itemlabel " + indicatorStyle + " active" : 'itemlabel',
      disabled: el.disabled
    }, el.icon, " ", el.label, indicatorStyle === 'bottomLine' && React__default.createElement("div", {
      style: {
        backgroundColor: color
      }
    }));
  })), React__default.createElement("div", {
    className: "body"
  }, tabsItems.map(function (tabEl, index) {
    if (index < activeTab) {
      return React__default.createElement("div", {
        style: {
          transform: 'translate3d(-100%, 0px, 0px)',
          height: '0px',
          overflow: 'hidden',
          transition: "transform " + transitionMs / 1000 + "s ease"
        },
        key: index,
        className: 'body-content'
      }, !lazy && tabEl);
    }

    if (index > activeTab) {
      return React__default.createElement("div", {
        style: {
          transform: 'translate3d(100%, 0px, 0px)',
          height: '0px',
          overflow: 'hidden',
          transition: "transform " + transitionMs / 1000 + "s ease"
        },
        key: index,
        className: 'body-content'
      }, !lazy && tabEl);
    } else {
      return React__default.createElement("div", {
        style: {
          visibility: 'inherit',
          overflow: 'auto',
          height: 'auto',
          position: 'relative',
          transition: "transform " + transitionMs / 1000 + "s ease"
        },
        key: index,
        className: 'body-content'
      }, tabEl);
    }
  })));
});
var TabItem = React.memo(function (_ref2) {
  var children = _ref2.children;
  return React__default.createElement("div", {
    style: {
      padding: '1rem 0.5rem'
    }
  }, children);
});

var _excluded = ["onInputChangedEnd", "onChangedDelayed", "onChangedValue", "delayMs"];
var Input = React.memo(function (props) {
  var onInputChangedEnd = props.onInputChangedEnd,
      onChangedDelayed = props.onChangedDelayed,
      onChangedValue = props.onChangedValue,
      delayMs = props.delayMs,
      restProps = _objectWithoutPropertiesLoose(props, _excluded);

  var _useState = React.useState(props.value),
      state = _useState[0],
      setState = _useState[1];

  var timerRef = React.useRef();
  var mountRef = React.useRef(true);
  var flagRef = React.useRef(false);
  React.useEffect(function () {
    if (!onChangedDelayed) return;

    if (mountRef.current) {
      mountRef.current = false;
      return;
    }

    if (flagRef.current) {
      return;
    }

    timerRef.current = setTimeout(function () {
      flagRef.current = true;
      clearTimeout(timerRef.current);
      onChangedDelayed(state);
      flagRef.current = false;
    }, delayMs || 100);
    return function () {
      clearTimeout(timerRef.current);
    };
  }, [state]);

  function changeValue(e) {
    if (['checkbox', 'radio'].includes(props.type)) {
      setState(e.target.checked);
      onChangedValue && onChangedValue(e.target.checked);
    } else {
      setState(e.target.value);
      onChangedValue && onChangedValue(e.target.value);
    }
  }

  return React__default.createElement(React__default.Fragment, null, onInputChangedEnd && React__default.createElement("input", Object.assign({}, restProps, {
    className: restProps === null || restProps === void 0 ? void 0 : restProps.className,
    style: restProps.style,
    value: props.value,
    onChange: changeValue,
    onBlur: function onBlur(e) {
      onInputChangedEnd(e.target.value);
    },
    onKeyDown: function onKeyDown(e) {
      if (e.key == 'Enter') onInputChangedEnd(state);
    }
  })), !onInputChangedEnd && React__default.createElement("input", Object.assign({}, restProps, {
    className: restProps === null || restProps === void 0 ? void 0 : restProps.className,
    style: restProps.style,
    value: props.value,
    onChange: changeValue
  })));
});

var _initialState = {
  contrast: 1,
  blur: 0,
  brightness: 1,
  grayscale: 0,
  invert: 0,
  saturate: 1,
  sepia: 0
};
var BasicFilter = React.memo(function (_ref) {
  var labels = _ref.labels,
      color = _ref.color,
      _ref$initialState = _ref.initialState,
      initialState = _ref$initialState === void 0 ? _initialState : _ref$initialState,
      _ref$changeFilter = _ref.changeFilter,
      changeFilter = _ref$changeFilter === void 0 ? function () {} : _ref$changeFilter;

  var _useState = React.useState(initialState),
      state = _useState[0],
      setState = _useState[1];

  React.useEffect(function () {
    if (initialState) {
      setState(JSON.parse(JSON.stringify(_extends({}, state, initialState))));
    } else {
      setState(_initialState);
    }
  }, [initialState]);

  function onUpdateContrast(contrast) {
    changeFilter(_extends({}, state, {
      contrast: contrast
    }));
  }

  function onUpdateBrightness(brightness) {
    changeFilter(_extends({}, state, {
      brightness: brightness
    }));
  }

  function onUpdateGrayscale(grayscale) {
    changeFilter(_extends({}, state, {
      grayscale: grayscale
    }));
  }

  function onUpdateSaturate(saturate) {
    changeFilter(_extends({}, state, {
      saturate: saturate
    }));
  }

  function onUpdateSepia(sepia) {
    changeFilter(_extends({}, state, {
      sepia: sepia
    }));
  }

  function onUpdateBlur(blur) {
    changeFilter(_extends({}, state, {
      blur: blur
    }));
  }

  return React__default.createElement("div", null, React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Contrast']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.contrast).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateContrast,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        contrast: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.contrast
  })), React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Brightness']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.brightness).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateBrightness,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        brightness: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.brightness
  })), React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Grayscale']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.grayscale).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateGrayscale,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        grayscale: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.grayscale
  })), React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Saturate']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.saturate).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateSaturate,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        saturate: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.saturate
  })), React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Sepia']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.sepia).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateSepia,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        sepia: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.sepia
  })), React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Blur']), React__default.createElement("p", {
    className: "item-panel"
  }, (+state.blur).toFixed(2))), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    className: "input-range",
    onChangedDelayed: onUpdateBlur,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        blur: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: "0",
    max: "5",
    step: "0.01",
    value: state.blur
  })));
});

(function () {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];

  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})();

(function () {
  if (typeof window.CustomEvent === "function") return false;

  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();

(function (window) {
  try {
    new CustomEvent("test");
    return false;
  } catch (e) {}

  function MouseEvent(eventType, params) {
    params = params || {
      bubbles: false,
      cancelable: false
    };
    var mouseEvent = document.createEvent("MouseEvent");
    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    return mouseEvent;
  }

  MouseEvent.prototype = Event.prototype;
  window.MouseEvent = MouseEvent;
})(window);

var Handle = function Handle(position, constraints, cursor, eventBus) {
  var self = this;
  this.position = position;
  this.constraints = constraints;
  this.cursor = cursor;
  this.eventBus = eventBus;
  this.el = document.createElement("div");
  this.el.className = "croppr-handle";
  this.el.style.cursor = cursor;
  this.el.addEventListener("mousedown", onMouseDown);

  function onMouseDown(e) {
    e.stopPropagation();
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    self.eventBus.dispatchEvent(new CustomEvent("handlestart", {
      detail: {
        handle: self
      }
    }));
  }

  function onMouseUp(e) {
    e.stopPropagation();
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("mousemove", onMouseMove);
    self.eventBus.dispatchEvent(new CustomEvent("handleend", {
      detail: {
        handle: self
      }
    }));
  }

  function onMouseMove(e) {
    e.stopPropagation();
    self.eventBus.dispatchEvent(new CustomEvent("handlemove", {
      detail: {
        mouseX: e.clientX,
        mouseY: e.clientY
      }
    }));
  }
};

var Box = /*#__PURE__*/function () {
  function Box(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  var _proto = Box.prototype;

  _proto.set = function set(x1, y1, x2, y2) {
    if (x1 === void 0) {
      x1 = null;
    }

    if (y1 === void 0) {
      y1 = null;
    }

    if (x2 === void 0) {
      x2 = null;
    }

    if (y2 === void 0) {
      y2 = null;
    }

    this.x1 = x1 == null ? this.x1 : x1;
    this.y1 = y1 == null ? this.y1 : y1;
    this.x2 = x2 == null ? this.x2 : x2;
    this.y2 = y2 == null ? this.y2 : y2;
    return this;
  };

  _proto.width = function width() {
    return Math.abs(this.x2 - this.x1);
  };

  _proto.height = function height() {
    return Math.abs(this.y2 - this.y1);
  };

  _proto.resize = function resize(newWidth, newHeight, origin) {
    if (origin === void 0) {
      origin = [0, 0];
    }

    var fromX = this.x1 + this.width() * origin[0];
    var fromY = this.y1 + this.height() * origin[1];
    this.x1 = fromX - newWidth * origin[0];
    this.y1 = fromY - newHeight * origin[1];
    this.x2 = this.x1 + newWidth;
    this.y2 = this.y1 + newHeight;
    return this;
  };

  _proto.scale = function scale(factor, origin) {
    if (origin === void 0) {
      origin = [0, 0];
    }

    var newWidth = this.width() * factor;
    var newHeight = this.height() * factor;
    this.resize(newWidth, newHeight, origin);
    return this;
  };

  _proto.move = function move(x, y) {
    if (x === void 0) {
      x = null;
    }

    if (y === void 0) {
      y = null;
    }

    var width = this.width();
    var height = this.height();
    x = x === null ? this.x1 : x;
    y = y === null ? this.y1 : y;
    this.x1 = x;
    this.y1 = y;
    this.x2 = x + width;
    this.y2 = y + height;
    return this;
  };

  _proto.getRelativePoint = function getRelativePoint(point) {
    if (point === void 0) {
      point = [0, 0];
    }

    var x = this.width() * point[0];
    var y = this.height() * point[1];
    return [x, y];
  };

  _proto.getAbsolutePoint = function getAbsolutePoint(point) {
    if (point === void 0) {
      point = [0, 0];
    }

    var x = this.x1 + this.width() * point[0];
    var y = this.y1 + this.height() * point[1];
    return [x, y];
  };

  _proto.constrainToRatio = function constrainToRatio(ratio, origin, grow) {
    if (origin === void 0) {
      origin = [0, 0];
    }

    if (grow === void 0) {
      grow = "height";
    }

    if (ratio === null) {
      return;
    }

    var width = this.width();
    var height = this.height();

    switch (grow) {
      case "height":
        this.resize(this.width(), this.width() * ratio, origin);
        break;

      case "width":
        this.resize(this.height() * 1 / ratio, this.height(), origin);
        break;

      default:
        this.resize(this.width(), this.width() * ratio, origin);
    }

    return this;
  };

  _proto.constrainToBoundary = function constrainToBoundary(boundaryWidth, boundaryHeight, origin) {
    if (origin === void 0) {
      origin = [0, 0];
    }

    var _this$getAbsolutePoin = this.getAbsolutePoint(origin),
        originX = _this$getAbsolutePoin[0],
        originY = _this$getAbsolutePoin[1];

    var maxIfLeft = originX;
    var maxIfTop = originY;
    var maxIfRight = boundaryWidth - originX;
    var maxIfBottom = boundaryHeight - originY;
    var directionX = -2 * origin[0] + 1;
    var directionY = -2 * origin[1] + 1;
    var maxWidth = null,
        maxHeight = null;

    switch (directionX) {
      case -1:
        maxWidth = maxIfLeft;
        break;

      case 0:
        maxWidth = Math.min(maxIfLeft, maxIfRight) * 2;
        break;

      case +1:
        maxWidth = maxIfRight;
        break;
    }

    switch (directionY) {
      case -1:
        maxHeight = maxIfTop;
        break;

      case 0:
        maxHeight = Math.min(maxIfTop, maxIfBottom) * 2;
        break;

      case +1:
        maxHeight = maxIfBottom;
        break;
    }

    if (this.width() > maxWidth) {
      var factor = maxWidth / this.width();
      this.scale(factor, origin);
    }

    if (this.height() > maxHeight) {
      var _factor = maxHeight / this.height();

      this.scale(_factor, origin);
    }

    return this;
  };

  _proto.constrainToSize = function constrainToSize(maxWidth, maxHeight, minWidth, minHeight, origin, ratio) {
    if (maxWidth === void 0) {
      maxWidth = null;
    }

    if (maxHeight === void 0) {
      maxHeight = null;
    }

    if (minWidth === void 0) {
      minWidth = null;
    }

    if (minHeight === void 0) {
      minHeight = null;
    }

    if (origin === void 0) {
      origin = [0, 0];
    }

    if (ratio === void 0) {
      ratio = null;
    }

    if (ratio) {
      if (ratio > 1) {
        maxWidth = maxHeight * 1 / ratio;
        minHeight = minHeight * ratio;
      } else if (ratio < 1) {
        maxHeight = maxWidth * ratio;
        minWidth = minHeight * 1 / ratio;
      }
    }

    if (maxWidth && this.width() > maxWidth) {
      var newWidth = maxWidth,
          newHeight = ratio === null ? this.height() : maxHeight;
      this.resize(newWidth, newHeight, origin);
    }

    if (maxHeight && this.height() > maxHeight) {
      var _newWidth = ratio === null ? this.width() : maxWidth,
          _newHeight = maxHeight;

      this.resize(_newWidth, _newHeight, origin);
    }

    if (minWidth && this.width() < minWidth) {
      var _newWidth2 = minWidth,
          _newHeight2 = ratio === null ? this.height() : minHeight;

      this.resize(_newWidth2, _newHeight2, origin);
    }

    if (minHeight && this.height() < minHeight) {
      var _newWidth3 = ratio === null ? this.width() : minWidth,
          _newHeight3 = minHeight;

      this.resize(_newWidth3, _newHeight3, origin);
    }

    return this;
  };

  return Box;
}();

function enableTouch(element) {
  element.addEventListener("touchstart", simulateMouseEvent);
  element.addEventListener("touchend", simulateMouseEvent);
  element.addEventListener("touchmove", simulateMouseEvent);
}

function simulateMouseEvent(e) {
  e.preventDefault();
  var touch = e.changedTouches[0];
  var eventMap = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup"
  };
  touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {
    bubbles: true,
    cancelable: true,
    view: window,
    clientX: touch.clientX,
    clientY: touch.clientY,
    screenX: touch.screenX,
    screenY: touch.screenY
  }));
}

var HANDLES = [{
  position: [0.0, 0.0],
  constraints: [1, 0, 0, 1],
  cursor: "nw-resize"
}, {
  position: [0.5, 0.0],
  constraints: [1, 0, 0, 0],
  cursor: "n-resize"
}, {
  position: [1.0, 0.0],
  constraints: [1, 1, 0, 0],
  cursor: "ne-resize"
}, {
  position: [1.0, 0.5],
  constraints: [0, 1, 0, 0],
  cursor: "e-resize"
}, {
  position: [1.0, 1.0],
  constraints: [0, 1, 1, 0],
  cursor: "se-resize"
}, {
  position: [0.5, 1.0],
  constraints: [0, 0, 1, 0],
  cursor: "s-resize"
}, {
  position: [0.0, 1.0],
  constraints: [0, 0, 1, 1],
  cursor: "sw-resize"
}, {
  position: [0.0, 0.5],
  constraints: [0, 0, 0, 1],
  cursor: "w-resize"
}];

var CropprCore = /*#__PURE__*/function () {
  function CropprCore(element, options, deferred) {
    var _this = this;

    if (deferred === void 0) {
      deferred = false;
    }

    this.options = CropprCore.parseOptions(options || {});

    if (!element.nodeName) {
      element = document.querySelector(element);

      if (element == null) {
        throw "Unable to find element.";
      }
    }

    if (!element.getAttribute("src")) {
      throw "Image src not provided.";
    }

    this._initialized = false;
    this._restore = {
      parent: element.parentNode,
      element: element
    };

    if (!deferred) {
      if (element.width === 0 || element.height === 0) {
        element.onload = function () {
          _this.initialize(element);
        };
      } else {
        this.initialize(element);
      }
    }
  }

  var _proto = CropprCore.prototype;

  _proto.initialize = function initialize(element) {
    this.createDOM(element);
    this.options.convertToPixels(this.cropperEl);
    this.attachHandlerEvents();
    this.attachRegionEvents();
    this.attachOverlayEvents();
    this.box = this.initializeBox(this.options);
    this.redraw();
    this._initialized = true;

    if (this.options.onInitialize !== null) {
      this.options.onInitialize(this);
    }
  };

  _proto.createDOM = function createDOM(targetEl) {
    this.containerEl = document.createElement("div");
    this.containerEl.className = "croppr-container";
    this.eventBus = this.containerEl;
    enableTouch(this.containerEl);
    this.cropperEl = document.createElement("div");
    this.cropperEl.className = "croppr";
    this.imageEl = document.createElement("img");
    this.imageEl.setAttribute("src", targetEl.getAttribute("src"));
    this.imageEl.setAttribute("alt", targetEl.getAttribute("alt"));
    this.imageEl.className = "croppr-image";
    this.imageClippedEl = this.imageEl.cloneNode();
    this.imageClippedEl.className = "croppr-imageClipped";
    this.regionEl = document.createElement("div");
    this.regionEl.innerHTML = new Array(9).fill(1).map(function () {
      return "<div style=\"border: 1px dashed #fafafa\"></div>";
    }).join("");
    this.regionEl.className = "croppr-region";
    this.overlayEl = document.createElement("div");
    this.overlayEl.className = "croppr-overlay";
    var handleContainerEl = document.createElement("div");
    handleContainerEl.className = "croppr-handleContainer";
    this.handles = [];

    for (var i = 0; i < HANDLES.length; i++) {
      var handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);
      this.handles.push(handle);
      handleContainerEl.appendChild(handle.el);
    }

    this.cropperEl.appendChild(this.imageEl);
    this.cropperEl.appendChild(this.imageClippedEl);
    this.cropperEl.appendChild(this.regionEl);
    this.cropperEl.appendChild(this.overlayEl);
    this.cropperEl.appendChild(handleContainerEl);
    this.containerEl.appendChild(this.cropperEl);
    targetEl.parentElement.replaceChild(this.containerEl, targetEl);
  };

  _proto.setImage = function setImage(src) {
    var _this2 = this;

    this.imageEl.onload = function () {
      _this2.box = _this2.initializeBox(_this2.options);

      _this2.redraw();
    };

    this.imageEl.src = src;
    this.imageClippedEl.src = src;
    return this;
  };

  _proto.destroy = function destroy() {
    this._restore.parent.replaceChild(this._restore.element, this.containerEl);
  };

  _proto.initializeBox = function initializeBox(opts) {
    var width = opts.startSize.width;
    var height = opts.startSize.height;
    var box = new Box(0, 0, width, height);
    box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);
    var min = opts.minSize;
    var max = opts.maxSize;
    box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);
    var parentWidth = this.cropperEl.offsetWidth;
    var parentHeight = this.cropperEl.offsetHeight;
    box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
    var x = this.cropperEl.offsetWidth / 2 - box.width() / 2;
    var y = this.cropperEl.offsetHeight / 2 - box.height() / 2;
    box.move(x, y);
    return box;
  };

  _proto.redraw = function redraw() {
    var _this3 = this;

    var width = Math.round(this.box.width()),
        height = Math.round(this.box.height()),
        x1 = Math.round(this.box.x1),
        y1 = Math.round(this.box.y1),
        x2 = Math.round(this.box.x2),
        y2 = Math.round(this.box.y2);
    window.requestAnimationFrame(function () {
      _this3.regionEl.style.transform = "translate(" + x1 + "px, " + y1 + "px)";
      _this3.regionEl.style.width = width + "px";
      _this3.regionEl.style.height = height + "px";
      _this3.imageClippedEl.style.clip = "rect(" + y1 + "px, " + x2 + "px, " + y2 + "px, " + x1 + "px)";

      var center = _this3.box.getAbsolutePoint([0.5, 0.5]);

      var xSign = center[0] - _this3.cropperEl.offsetWidth / 2 >> 31;
      var ySign = center[1] - _this3.cropperEl.offsetHeight / 2 >> 31;
      var quadrant = (xSign ^ ySign) + ySign + ySign + 4;
      var foregroundHandleIndex = -2 * quadrant + 8;

      for (var i = 0; i < _this3.handles.length; i++) {
        var handle = _this3.handles[i];
        var handleWidth = handle.el.offsetWidth;
        var handleHeight = handle.el.offsetHeight;
        var left = x1 + width * handle.position[0] - handleWidth / 2;
        var top = y1 + height * handle.position[1] - handleHeight / 2;
        handle.el.style.transform = "translate(" + Math.round(left) + "px, " + Math.round(top) + "px)";
        handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;
      }
    });
  };

  _proto.attachHandlerEvents = function attachHandlerEvents() {
    var eventBus = this.eventBus;
    eventBus.addEventListener("handlestart", this.onHandleMoveStart.bind(this));
    eventBus.addEventListener("handlemove", this.onHandleMoveMoving.bind(this));
    eventBus.addEventListener("handleend", this.onHandleMoveEnd.bind(this));
  };

  _proto.attachRegionEvents = function attachRegionEvents() {
    var eventBus = this.eventBus;
    this.regionEl.addEventListener("mousedown", onMouseDown);
    eventBus.addEventListener("regionstart", this.onRegionMoveStart.bind(this));
    eventBus.addEventListener("regionmove", this.onRegionMoveMoving.bind(this));
    eventBus.addEventListener("regionend", this.onRegionMoveEnd.bind(this));

    function onMouseDown(e) {
      e.stopPropagation();
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", onMouseMove);
      eventBus.dispatchEvent(new CustomEvent("regionstart", {
        detail: {
          mouseX: e.clientX,
          mouseY: e.clientY
        }
      }));
    }

    function onMouseMove(e) {
      e.stopPropagation();
      eventBus.dispatchEvent(new CustomEvent("regionmove", {
        detail: {
          mouseX: e.clientX,
          mouseY: e.clientY
        }
      }));
    }

    function onMouseUp(e) {
      e.stopPropagation();
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
      eventBus.dispatchEvent(new CustomEvent("regionend", {
        detail: {
          mouseX: e.clientX,
          mouseY: e.clientY
        }
      }));
    }
  };

  _proto.attachOverlayEvents = function attachOverlayEvents() {
    var SOUTHEAST_HANDLE_IDX = 4;
    var self = this;
    var tmpBox = null;
    this.overlayEl.addEventListener("mousedown", onMouseDown);

    function onMouseDown(e) {
      e.stopPropagation();
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", onMouseMove);
      var container = self.cropperEl.getBoundingClientRect();
      var mouseX = e.clientX - container.left;
      var mouseY = e.clientY - container.top;
      tmpBox = self.box;
      self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);
      self.eventBus.dispatchEvent(new CustomEvent("handlestart", {
        detail: {
          handle: self.handles[SOUTHEAST_HANDLE_IDX]
        }
      }));
    }

    function onMouseMove(e) {
      e.stopPropagation();
      self.eventBus.dispatchEvent(new CustomEvent("handlemove", {
        detail: {
          mouseX: e.clientX,
          mouseY: e.clientY
        }
      }));
    }

    function onMouseUp(e) {
      e.stopPropagation();
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);

      if (self.box.width() === 1 && self.box.height() === 1) {
        self.box = tmpBox;
        return;
      }

      self.eventBus.dispatchEvent(new CustomEvent("handleend", {
        detail: {
          mouseX: e.clientX,
          mouseY: e.clientY
        }
      }));
    }
  };

  _proto.onHandleMoveStart = function onHandleMoveStart(e) {
    var handle = e.detail.handle;
    var originPoint = [1 - handle.position[0], 1 - handle.position[1]];

    var _this$box$getAbsolute = this.box.getAbsolutePoint(originPoint),
        originX = _this$box$getAbsolute[0],
        originY = _this$box$getAbsolute[1];

    this.activeHandle = {
      handle: handle,
      originPoint: originPoint,
      originX: originX,
      originY: originY
    };

    if (this.options.onCropStart !== null) {
      this.options.onCropStart(this.getValue());
    }
  };

  _proto.onHandleMoveMoving = function onHandleMoveMoving(e) {
    var _e$detail = e.detail,
        mouseX = _e$detail.mouseX,
        mouseY = _e$detail.mouseY;
    var container = this.cropperEl.getBoundingClientRect();
    mouseX = mouseX - container.left;
    mouseY = mouseY - container.top;

    if (mouseX < 0) {
      mouseX = 0;
    } else if (mouseX > container.width) {
      mouseX = container.width;
    }

    if (mouseY < 0) {
      mouseY = 0;
    } else if (mouseY > container.height) {
      mouseY = container.height;
    }

    var origin = this.activeHandle.originPoint.slice();
    var originX = this.activeHandle.originX;
    var originY = this.activeHandle.originY;
    var handle = this.activeHandle.handle;
    var TOP_MOVABLE = handle.constraints[0] === 1;
    var RIGHT_MOVABLE = handle.constraints[1] === 1;
    var BOTTOM_MOVABLE = handle.constraints[2] === 1;
    var LEFT_MOVABLE = handle.constraints[3] === 1;
    var MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);
    var x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;
    var x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;
    var y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;
    var y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;
    x1 = LEFT_MOVABLE ? mouseX : x1;
    x2 = RIGHT_MOVABLE ? mouseX : x2;
    y1 = TOP_MOVABLE ? mouseY : y1;
    y2 = BOTTOM_MOVABLE ? mouseY : y2;
    var isFlippedX = false,
        isFlippedY = false;

    if (LEFT_MOVABLE || RIGHT_MOVABLE) {
      isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;
    }

    if (TOP_MOVABLE || BOTTOM_MOVABLE) {
      isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;
    }

    if (isFlippedX) {
      var tmp = x1;
      x1 = x2;
      x2 = tmp;
      origin[0] = 1 - origin[0];
    }

    if (isFlippedY) {
      var _tmp = y1;
      y1 = y2;
      y2 = _tmp;
      origin[1] = 1 - origin[1];
    }

    var box = new Box(x1, y1, x2, y2);

    if (this.options.aspectRatio) {
      var ratio = this.options.aspectRatio;
      var isVerticalMovement = false;

      if (MULTI_AXIS) {
        isVerticalMovement = mouseY > box.y1 + ratio * box.width() || mouseY < box.y2 - ratio * box.width();
      } else if (TOP_MOVABLE || BOTTOM_MOVABLE) {
        isVerticalMovement = true;
      }

      var ratioMode = isVerticalMovement ? "width" : "height";
      box.constrainToRatio(ratio, origin, ratioMode);
    }

    var min = this.options.minSize;
    var max = this.options.maxSize;
    box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);
    var parentWidth = this.cropperEl.offsetWidth;
    var parentHeight = this.cropperEl.offsetHeight;
    box.constrainToBoundary(parentWidth, parentHeight, origin);
    this.box = box;
    this.redraw();

    if (this.options.onCropMove !== null) {
      this.options.onCropMove(this.getValue());
    }
  };

  _proto.onHandleMoveEnd = function onHandleMoveEnd(e) {
    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }
  };

  _proto.onRegionMoveStart = function onRegionMoveStart(e) {
    var _e$detail2 = e.detail,
        mouseX = _e$detail2.mouseX,
        mouseY = _e$detail2.mouseY;
    var container = this.cropperEl.getBoundingClientRect();
    mouseX = mouseX - container.left;
    mouseY = mouseY - container.top;
    this.currentMove = {
      offsetX: mouseX - this.box.x1,
      offsetY: mouseY - this.box.y1
    };

    if (this.options.onCropStart !== null) {
      this.options.onCropStart(this.getValue());
    }
  };

  _proto.onRegionMoveMoving = function onRegionMoveMoving(e) {
    var _e$detail3 = e.detail,
        mouseX = _e$detail3.mouseX,
        mouseY = _e$detail3.mouseY;
    var _this$currentMove = this.currentMove,
        offsetX = _this$currentMove.offsetX,
        offsetY = _this$currentMove.offsetY;
    var container = this.cropperEl.getBoundingClientRect();
    mouseX = mouseX - container.left;
    mouseY = mouseY - container.top;
    this.box.move(mouseX - offsetX, mouseY - offsetY);

    if (this.box.x1 < 0) {
      this.box.move(0, null);
    }

    if (this.box.x2 > container.width) {
      this.box.move(container.width - this.box.width(), null);
    }

    if (this.box.y1 < 0) {
      this.box.move(null, 0);
    }

    if (this.box.y2 > container.height) {
      this.box.move(null, container.height - this.box.height());
    }

    this.redraw();

    if (this.options.onCropMove !== null) {
      this.options.onCropMove(this.getValue());
    }
  };

  _proto.onRegionMoveEnd = function onRegionMoveEnd(e) {
    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }
  };

  _proto.getValue = function getValue(mode) {
    if (mode === void 0) {
      mode = null;
    }

    if (mode === null) {
      mode = this.options.returnMode;
    }

    if (mode == "real") {
      var actualWidth = this.imageEl.naturalWidth;
      var actualHeight = this.imageEl.naturalHeight;

      var _this$imageEl$getBoun = this.imageEl.getBoundingClientRect(),
          elementWidth = _this$imageEl$getBoun.width,
          elementHeight = _this$imageEl$getBoun.height;

      var factorX = actualWidth / elementWidth;
      var factorY = actualHeight / elementHeight;
      return {
        x: Math.round(this.box.x1 * factorX),
        y: Math.round(this.box.y1 * factorY),
        width: Math.round(this.box.width() * factorX),
        height: Math.round(this.box.height() * factorY)
      };
    } else if (mode == "ratio") {
      var _this$imageEl$getBoun2 = this.imageEl.getBoundingClientRect(),
          _elementWidth = _this$imageEl$getBoun2.width,
          _elementHeight = _this$imageEl$getBoun2.height;

      return {
        x: round(this.box.x1 / _elementWidth, 3),
        y: round(this.box.y1 / _elementHeight, 3),
        width: round(this.box.width() / _elementWidth, 3),
        height: round(this.box.height() / _elementHeight, 3)
      };
    } else if (mode == "raw") {
      return {
        x: Math.round(this.box.x1),
        y: Math.round(this.box.y1),
        width: Math.round(this.box.width()),
        height: Math.round(this.box.height())
      };
    }
  };

  CropprCore.parseOptions = function parseOptions(opts) {
    var defaults = {
      aspectRatio: null,
      maxSize: {
        width: null,
        height: null
      },
      minSize: {
        width: null,
        height: null
      },
      startSize: {
        width: 100,
        height: 100,
        unit: "%"
      },
      returnMode: "real",
      onInitialize: null,
      onCropStart: null,
      onCropMove: null,
      onCropEnd: null
    };
    var aspectRatio = null;

    if (opts.aspectRatio !== undefined) {
      if (typeof opts.aspectRatio === "number") {
        aspectRatio = opts.aspectRatio;
      } else if (opts.aspectRatio instanceof Array) {
        aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];
      }
    }

    var maxSize = null;

    if (opts.maxSize !== undefined && opts.maxSize !== null) {
      maxSize = {
        width: opts.maxSize[0] || null,
        height: opts.maxSize[1] || null,
        unit: opts.maxSize[2] || "px"
      };
    }

    var minSize = null;

    if (opts.minSize !== undefined && opts.minSize !== null) {
      minSize = {
        width: opts.minSize[0] || null,
        height: opts.minSize[1] || null,
        unit: opts.minSize[2] || "px"
      };
    }

    var startSize = null;

    if (opts.startSize !== undefined && opts.startSize !== null) {
      startSize = {
        width: opts.startSize[0] || null,
        height: opts.startSize[1] || null,
        unit: opts.startSize[2] || "%"
      };
    }

    var onInitialize = null;

    if (typeof opts.onInitialize === "function") {
      onInitialize = opts.onInitialize;
    }

    var onCropStart = null;

    if (typeof opts.onCropStart === "function") {
      onCropStart = opts.onCropStart;
    }

    var onCropEnd = null;

    if (typeof opts.onCropEnd === "function") {
      onCropEnd = opts.onCropEnd;
    }

    var onCropMove = null;

    if (typeof opts.onUpdate === "function") {
      console.warn("Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.");
      onCropMove = opts.onUpdate;
    }

    if (typeof opts.onCropMove === "function") {
      onCropMove = opts.onCropMove;
    }

    var returnMode = null;

    if (opts.returnMode !== undefined) {
      var s = opts.returnMode.toLowerCase();

      if (["real", "ratio", "raw"].indexOf(s) === -1) {
        throw "Invalid return mode.";
      }

      returnMode = s;
    }

    var convertToPixels = function convertToPixels(container) {
      var width = container.offsetWidth;
      var height = container.offsetHeight;
      var sizeKeys = ["maxSize", "minSize", "startSize"];

      for (var i = 0; i < sizeKeys.length; i++) {
        var key = sizeKeys[i];

        if (this[key] !== null) {
          if (this[key].unit == "%") {
            if (this[key].width !== null) {
              this[key].width = this[key].width / 100 * width;
            }

            if (this[key].height !== null) {
              this[key].height = this[key].height / 100 * height;
            }
          }

          delete this[key].unit;
        }
      }
    };

    var defaultValue = function defaultValue(v, d) {
      return v !== null ? v : d;
    };

    return {
      aspectRatio: defaultValue(aspectRatio, defaults.aspectRatio),
      maxSize: defaultValue(maxSize, defaults.maxSize),
      minSize: defaultValue(minSize, defaults.minSize),
      startSize: defaultValue(startSize, defaults.startSize),
      returnMode: defaultValue(returnMode, defaults.returnMode),
      onInitialize: defaultValue(onInitialize, defaults.onInitialize),
      onCropStart: defaultValue(onCropStart, defaults.onCropStart),
      onCropMove: defaultValue(onCropMove, defaults.onCropMove),
      onCropEnd: defaultValue(onCropEnd, defaults.onCropEnd),
      convertToPixels: convertToPixels
    };
  };

  return CropprCore;
}();

function round(value, decimals) {
  return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
}

var Croppr = /*#__PURE__*/function (_CropprCore) {
  _inheritsLoose(Croppr, _CropprCore);

  function Croppr(element, options, _deferred) {
    if (_deferred === void 0) {
      _deferred = false;
    }

    return _CropprCore.call(this, element, options, _deferred) || this;
  }

  var _proto = Croppr.prototype;

  _proto.getValue = function getValue(mode) {
    return _CropprCore.prototype.getValue.call(this, mode);
  };

  _proto.setImage = function setImage(src) {
    return _CropprCore.prototype.setImage.call(this, src);
  };

  _proto.destroy = function destroy() {
    return _CropprCore.prototype.destroy.call(this);
  };

  _proto.moveTo = function moveTo(x, y) {
    this.box.move(x, y);
    this.redraw();

    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }

    return this;
  };

  _proto.resizeTo = function resizeTo(width, height, origin) {
    if (origin === void 0) {
      origin = [0.5, 0.5];
    }

    this.box.resize(width, height, origin);
    var parentWidth = this.cropperEl.offsetWidth;
    var parentHeight = this.cropperEl.offsetHeight;
    this.box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
    this.redraw();

    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }

    return this;
  };

  _proto.scaleBy = function scaleBy(factor, origin) {
    if (origin === void 0) {
      origin = [0.5, 0.5];
    }

    this.box.scale(factor, origin);
    this.redraw();

    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }

    return this;
  };

  _proto.reset = function reset(newOptions) {
    if (newOptions) {
      this.options = _extends({}, this.options, {
        newOptions: newOptions
      });
    }

    this.box = this.initializeBox(this.options);
    this.redraw();

    if (this.options.onCropEnd !== null) {
      this.options.onCropEnd(this.getValue());
    }

    return this;
  };

  _proto.enableVisibility = function enableVisibility(state) {
    var croppContainer = document.querySelector(".croppr-container");
    if (!croppContainer) throw new Error("THere is not any croppr");

    if (state) {
      croppContainer.style.display = "block";
    } else {
      croppContainer.style.display = "none";
    }
  };

  return Croppr;
}(CropprCore);

var CropprWrapper = React.memo(function (_ref) {
  var src = _ref.src,
      size = _ref.size,
      croppUpdate = _ref.croppUpdate;

  var _useState = React.useState(),
      imageSrc = _useState[0],
      setImageSrc = _useState[1];

  var _useState2 = React.useState({
    width: 150,
    height: 150
  }),
      croppSize = _useState2[0],
      setCroppSize = _useState2[1];

  var croppr = React.useRef(null);
  var mount = React.useRef();
  React.useEffect(function () {
    if (size) {
      setCroppSize(_extends({}, size));
      if (croppr.current) croppr.current.resizeTo(size.width, size.height);
    }
  }, [size]);
  React.useEffect(function () {
    if (src) {
      setImageSrc(src);
    }
  }, [src]);
  React.useEffect(function () {
    if (mount.current && imageSrc) {
      croppr.current = new Croppr('#croppr', {
        minSize: [32, 32, 'px'],
        startSize: [croppSize.width, croppSize.height, 'px'],
        onInitialize: function onInitialize(data) {
          croppUpdate(data === null || data === void 0 ? void 0 : data.getValue());
        },
        onCropEnd: function onCropEnd(data) {
          croppUpdate(data);
        }
      });
    }

    return function () {
      var _croppr$current;

      return croppr === null || croppr === void 0 ? void 0 : (_croppr$current = croppr.current) === null || _croppr$current === void 0 ? void 0 : _croppr$current.destroy();
    };
  }, [mount.current, imageSrc]);
  return React__default.createElement("div", {
    className: 'CropprWrapper'
  }, React__default.createElement("img", {
    ref: mount,
    src: imageSrc,
    id: "croppr"
  }));
});

var _initialState$1 = {
  quality: 92,
  maxHeight: 1000,
  maxWidth: 1000,
  cropHeight: 150,
  cropWidth: 150,
  maintainAspectRatio: true,
  format: 'jpeg',
  arrayCopiedImages: [],
  originImageSrc: ''
};
var EditImage = React.memo(function (_ref) {
  var onChangeFilters = function onChangeFilters(data) {
    try {
      var _temp8 = _catch(function () {
        var newState = _cloneObject(state);

        if (!newState.basicFilters) {
          newState.basicFilters = data;
        } else {
          newState.basicFilters = _extends({}, newState.basicFilters, data);
        }

        return Promise.resolve(applyChanges(newState, false)).then(function () {});
      }, function (e) {
        console.log("🚀 ~ file: EditImage.tsx ~ line 259 ~ onChangeFilters ~ e", e);
      });

      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onRestore = function onRestore() {
    try {
      try {
        var newState = _cloneObject(state);

        if (newState.arrayCopiedImages.length > 1) {
          newState.arrayCopiedImages.pop();
          var newValue = newState.arrayCopiedImages[newState.arrayCopiedImages.length - 1];
          newState = _extends({}, state, {
            arrayCopiedImages: newState.arrayCopiedImages,
            maxHeight: newValue.height,
            maxWidth: newValue.width,
            quality: newValue.quality,
            format: newValue.format,
            originImageSrc: newValue.originImageSrc,
            basicFilters: newValue.basicFilters
          });
          setState(newState);
          setImageSrc(newValue.lastImage);
        }
      } catch (e) {
        console.log('🚀 ~ file: edit-image.component.ts ~ line 126 ~ EditImageComponent ~ onRestore ~ e', e);
      }

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onChangeFormat = function onChangeFormat(e) {
    try {
      var newState = _extends({}, state, {
        format: e.target.value
      });

      var _temp6 = _catch(function () {
        setState(newState);
        return Promise.resolve(applyChanges(newState, false)).then(function () {});
      }, function (error) {
        console.log("onChangeFormat ~ error", error);
      });

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onChangeSize = function onChangeSize(value, changeHeight) {
    if (changeHeight === void 0) {
      changeHeight = false;
    }

    try {
      var m = Math.max(Math.min(value, 4000), 32);

      var newState = _extends({}, state);

      if (changeHeight) {
        if (newState.maxHeight === m) return Promise.resolve();
        newState.maxHeight = m;
      } else {
        if (newState.maxWidth === m) return Promise.resolve();
        newState.maxWidth = m;
      }

      setState(newState);

      var _temp4 = _catch(function () {
        return Promise.resolve(applyChanges(newState, changeHeight)).then(function () {});
      }, function (error) {
        console.log("onChangeSize ~ error", error);
      });

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onUpdateQuality = function onUpdateQuality(quality) {
    try {
      quality = Math.max(Math.min(quality, 100), 1);

      var newState = _extends({}, state, {
        quality: quality
      });

      setState(newState);

      var _temp2 = _catch(function () {
        return Promise.resolve(applyChanges(newState, false)).then(function () {});
      }, function (error) {
        console.log("onUpdateQuality ~ error", error);
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var applyChanges = function applyChanges(stateIntance, changeHeight) {
    if (changeHeight === void 0) {
      changeHeight = false;
    }

    try {
      var _temp10 = _catch(function () {
        return Promise.resolve(convertImageUsingCanvas(state.originImageSrc, changeHeight, stateIntance)).then(function (_ref2) {
          var newState = _ref2.state,
              imageUri = _ref2.imageUri;
          setImageSrc(imageUri);
          setState(newState);
        });
      }, function (error) {
        console.log("🚀 ~ file: EditImage.tsx ~ line 73 ~ applyChanges ~ error", error);
      });

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _ref$labels = _ref.labels,
      labels = _ref$labels === void 0 ? {} : _ref$labels,
      _ref$image = _ref.image,
      image = _ref$image === void 0 ? '' : _ref$image,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? '#1e88e5' : _ref$color,
      _ref$initialState = _ref.initialState,
      initialState = _ref$initialState === void 0 ? _initialState$1 : _ref$initialState,
      _ref$saveUpdates = _ref.saveUpdates,
      saveUpdates = _ref$saveUpdates === void 0 ? function () {} : _ref$saveUpdates;

  var _useState = React.useState(initialState),
      state = _useState[0],
      setState = _useState[1];

  var _useState2 = React.useState(''),
      imageSrc = _useState2[0],
      setImageSrc = _useState2[1];

  var _useState3 = React.useState(false),
      showCrop = _useState3[0],
      setShowCrop = _useState3[1];

  var _useState4 = React.useState({
    width: 150,
    height: 150
  }),
      croppSize = _useState4[0],
      setCroppSize = _useState4[1];

  var _useState5 = React.useState(),
      croppState = _useState5[0],
      setCroppState = _useState5[1];

  var isMobile = React.useRef(false);
  var allFormats = ['webp', 'jpeg', 'png'];
  React.useEffect(function () {
    isMobile.current = window.innerWidth < 800;
    setState(JSON.parse(JSON.stringify(_extends({}, state, initialState))));
  }, [initialState]);
  React.useEffect(function () {
    setImageSrc(image);
  }, [image]);
  React.useEffect(function () {
    if (!showCrop) {
      setCroppSize({
        width: 150,
        height: 150
      });
    }
  }, [showCrop]);

  function onChangeCrop(width, height) {
    if (width) {
      setState(_extends({}, state, {
        cropWidth: width
      }));
      setCroppSize(_extends({}, croppSize, {
        width: width
      }));
    }

    if (height) {
      setState(_extends({}, state, {
        cropHeight: height
      }));
      setCroppSize(_extends({}, croppSize, {
        height: height
      }));
    }
  }

  function onCrop() {
    var newState = _cloneObject(state);

    var canvas = document.createElement('canvas');
    return new Promise(function (resolve, reject) {
      var ctx = canvas.getContext('2d');
      var image = new Image();
      image.src = imageSrc;

      image.onload = function () {
        var newWidth = croppState === null || croppState === void 0 ? void 0 : croppState.width;
        var newHeight = croppState === null || croppState === void 0 ? void 0 : croppState.height;
        canvas.height = newHeight;
        canvas.width = newWidth;
        ctx.drawImage(image, Math.abs(croppState === null || croppState === void 0 ? void 0 : croppState.x), Math.abs(croppState === null || croppState === void 0 ? void 0 : croppState.y), croppState === null || croppState === void 0 ? void 0 : croppState.width, croppState === null || croppState === void 0 ? void 0 : croppState.height, 0, 0, croppState === null || croppState === void 0 ? void 0 : croppState.width, croppState === null || croppState === void 0 ? void 0 : croppState.height);
        return resolve(canvas.toDataURL("image/" + newState.format, newState.quality));
      };

      image.onerror = function (e) {
        reject(e);
      };
    }).then(function (dataUri) {
      newState.maxWidth = canvas.width;
      newState.maxHeight = canvas.height;
      newState.originImageSrc = dataUri;
      newState = saveState(newState, dataUri);
      setState(newState);
      setImageSrc(dataUri);
      setShowCrop(false);
    })["catch"](function (e) {
      console.log(e);
    });
  }

  function onCroppUpdate(data) {
    setCroppState(data);
    setState(_extends({}, state, {
      cropHeight: data.height,
      cropWidth: data.width
    }));
  }

  function onCloseEditPanel(saveChanges) {
    if (saveChanges === void 0) {
      saveChanges = false;
    }

    setShowCrop(false);
    if (saveChanges) saveUpdates({
      state: state,
      imageSrc: imageSrc
    });else saveUpdates(null);
  }

  var sizeImage = React.useMemo(function () {
    if (imageSrc && imageSrc.length) {
      return Math.ceil(3 / 4 * imageSrc.length / 1024);
    } else {
      return '';
    }
  }, [imageSrc]);

  function _cloneObject(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  return React__default.createElement("div", {
    className: "EditImage"
  }, React__default.createElement("div", {
    id: "popup",
    className: "popup"
  }, React__default.createElement("div", {
    style: {
      flexDirection: 'row',
      'boxSizing': 'border-box',
      display: 'flex',
      'placeContent': 'center flex-end',
      'alignItems': 'center',
      padding: '0px 16px'
    }
  }, React__default.createElement("button", {
    className: "icon-btn",
    onClick: function onClick() {
      onCloseEditPanel(false);
    }
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "clear"))), React__default.createElement("div", {
    className: "image-container"
  }, React__default.createElement("div", {
    className: "image-holder-full"
  }, !showCrop && React__default.createElement("img", {
    id: "image-full",
    src: imageSrc
  }), showCrop && React__default.createElement(CropprWrapper, {
    src: imageSrc,
    size: croppSize,
    croppUpdate: onCroppUpdate
  })), React__default.createElement("div", {
    className: "control-panel"
  }, React__default.createElement(TabContainer, {
    lazy: true,
    borderLine: true
  }, React__default.createElement(TabItem, {
    name: "Basic"
  }, (!isMobile.current || isMobile.current && !showCrop) && React__default.createElement(React__default.Fragment, null, React__default.createElement("div", {
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("p", {
    className: "item-panel"
  }, labels['Quality']), React__default.createElement("p", {
    className: "item-panel"
  }, state.quality + '%')), React__default.createElement("div", {
    className: 'flex-row-start'
  }, React__default.createElement(Input, {
    readOnly: showCrop,
    disabled: showCrop,
    className: "input-range",
    onChangedDelayed: onUpdateQuality,
    onChangedValue: function onChangedValue(value) {
      setState(_extends({}, state, {
        quality: value
      }));
    },
    style: {
      maxWidth: '100%',
      width: '100%',
      color: color
    },
    type: "range",
    min: 1,
    max: 100,
    value: state.quality
  })), React__default.createElement("div", {
    className: "item-panel",
    style: {
      display: 'flex',
      width: '100%',
      justifyContent: 'space-between'
    }
  }, labels['Max dimensions'], React__default.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center'
    }
  }, React__default.createElement("input", {
    disabled: showCrop,
    readOnly: showCrop,
    type: "checkbox",
    checked: state.maintainAspectRatio,
    onChange: function onChange(e) {
      return setState(_extends({}, state, {
        maintainAspectRatio: e.target.checked
      }));
    },
    style: {
      color: color
    }
  }), React__default.createElement("span", {
    className: "caption"
  }, labels['aspect-ratio']))), React__default.createElement("div", {
    className: 'flex-row-start',
    style: {
      marginTop: '10px',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("div", {
    className: "form-field",
    style: {
      maxWidth: '48%',
      width: '48%'
    }
  }, React__default.createElement("label", null, labels['max-width(px)']), React__default.createElement(Input, {
    readOnly: showCrop,
    disabled: showCrop,
    placeholder: labels['max-width(px)'],
    value: state.maxWidth,
    onChangedValue: function onChangedValue(value) {
      return setState(_extends({}, state, {
        maxWidth: value
      }));
    },
    type: "number",
    min: 0,
    max: 2000,
    onInputChangedEnd: function onInputChangedEnd(value) {
      onChangeSize(value, false);
    }
  })), React__default.createElement("div", {
    className: "form-field",
    style: {
      maxWidth: '48%',
      width: '48%'
    }
  }, React__default.createElement("label", null, labels['max-height(px)']), React__default.createElement(Input, {
    readOnly: showCrop,
    disabled: showCrop,
    placeholder: labels['max-height(px)'],
    value: state.maxHeight,
    onChangedValue: function onChangedValue(value) {
      return setState(_extends({}, state, {
        maxHeight: value
      }));
    },
    type: "number",
    min: 0,
    max: 2000,
    onInputChangedEnd: function onInputChangedEnd(value) {
      onChangeSize(value, true);
    }
  }))), React__default.createElement("p", {
    className: "item-panel"
  }, labels['Format']), React__default.createElement("div", {
    className: 'flex-row-start',
    style: {
      marginTop: '10px',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("div", {
    className: "form-field",
    style: {
      width: '100%'
    }
  }, React__default.createElement("select", {
    disabled: showCrop,
    value: state.format,
    onChange: onChangeFormat
  }, allFormats.map(function (formatItem, index) {
    return React__default.createElement("option", {
      key: index,
      value: formatItem
    }, formatItem);
  }))))), React__default.createElement("div", {
    className: 'flex-row-start',
    style: {
      marginTop: '5px',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("span", {
    style: {
      display: 'flex',
      alignItems: 'center'
    }
  }, React__default.createElement("input", {
    type: "checkbox",
    onChange: function onChange(e) {
      setShowCrop(e.target.checked);
    },
    checked: showCrop,
    style: {
      color: color,
      marginBottom: '3px'
    }
  }), React__default.createElement("span", {
    className: "item-panel",
    style: {
      marginLeft: '4px'
    }
  }, labels['Crop']))), showCrop && React__default.createElement(React__default.Fragment, null, React__default.createElement("div", {
    className: 'flex-row-start',
    style: {
      marginTop: '10px',
      justifyContent: 'space-between'
    }
  }, React__default.createElement("div", {
    className: "form-field",
    style: {
      maxWidth: '48%',
      width: '48%'
    }
  }, React__default.createElement("label", null, labels['width(px)']), React__default.createElement(Input, {
    type: "number",
    min: 0,
    value: state.cropWidth,
    onChangedValue: function onChangedValue(value) {
      return setState(_extends({}, state, {
        cropWidth: value
      }));
    },
    onInputChangedEnd: function onInputChangedEnd(value) {
      onChangeCrop(+value, null);
    },
    placeholder: labels['width(px)']
  })), React__default.createElement("div", {
    className: "form-field",
    style: {
      maxWidth: '48%',
      width: '48%'
    }
  }, React__default.createElement("label", null, labels['height(px)']), React__default.createElement(Input, {
    type: "number",
    min: 0,
    value: state.cropHeight,
    onInputChangedEnd: function onInputChangedEnd(value) {
      onChangeCrop(null, +value);
    },
    onChangedValue: function onChangedValue(value) {
      return setState(_extends({}, state, {
        cropHeight: value
      }));
    },
    placeholder: labels['height(px)']
  }))), React__default.createElement("p", {
    style: {
      marginBottom: '4px !important'
    }
  }, React__default.createElement("button", {
    title: "Cut the image",
    className: "icon-btn",
    onClick: onCrop
  }, React__default.createElement("span", {
    className: "material-icons"
  }, " crop "))))), React__default.createElement(TabItem, {
    disabled: showCrop,
    name: "Filters"
  }, React__default.createElement(BasicFilter, {
    color: color,
    labels: labels,
    initialState: state.basicFilters,
    changeFilter: onChangeFilters
  }))), React__default.createElement("button", {
    title: labels['Undo'],
    disabled: state.arrayCopiedImages.length <= 1,
    style: {
      position: 'absolute',
      right: '10px',
      top: '30px'
    },
    className: "icon-btn",
    onClick: onRestore
  }, React__default.createElement("span", {
    className: "material-icons"
  }, " refresh ")), React__default.createElement("div", {
    className: 'flex-row-start',
    style: {
      marginTop: '10px',
      justifyContent: 'space-between',
      alignItems: 'center'
    }
  }, React__default.createElement("button", {
    className: "save-btn",
    onClick: function onClick() {
      onCloseEditPanel(true);
    }
  }, labels['Save']), sizeImage && React__default.createElement("p", {
    className: "caption image-caption",
    style: {
      color: sizeImage > 120 ? '#f44336' : 'unset',
      fontWeight: sizeImage > 120 ? '500' : 'unset'
    }
  }, "size: ", sizeImage, "Kb \xA0 ", state.format))))));
});

var initialConfig = {
  language: 'en',
  objectFit: 'cover',
  hideDeleteBtn: false,
  hideDownloadBtn: false,
  hideEditBtn: false,
  hideAddBtn: false
};
var ReactImagePickerEditor = React.memo(function (_ref) {
  var handleReaderLoaded = function handleReaderLoaded(readerEvt) {
    try {
      var binaryString = readerEvt.target.result;
      var base64textString = btoa(binaryString);

      var newState = _extends({}, state);

      var newImageSrc = urlImage.current + base64textString;
      newState.originImageSrc = urlImage.current + base64textString;

      var _temp4 = function () {
        if (configuration.compressInitial) {
          newState = _extends({}, newState, {
            quality: Math.min(configuration.compressInitial || 92, 100),
            maintainAspectRatio: true,
            format: 'jpeg'
          });
          return Promise.resolve(convertImageUsingCanvas(newState.originImageSrc, false, newState, {
            getDimFromImage: true
          })).then(function (result) {
            setState(result.state);
            setImageSrc(result.imageUri);
            imageChanged(result.imageUri);
            setLoadImage(true);
          });
        } else {
          var img = document.createElement('img');
          img.src = newImageSrc;

          img.onload = function () {
            newState.arrayCopiedImages = [];
            newState.maxHeight = img.height;
            newState.maxWidth = img.width;
            newState.format = fileType.current.split('image/')[1];
            newState.arrayCopiedImages.push({
              lastImage: newImageSrc,
              width: img.width,
              height: img.height,
              quality: newState.quality,
              format: fileType.current.split('image/')[1],
              originImageSrc: newState.originImageSrc
            });
            setState(newState);
            setImageSrc(newImageSrc);
            imageChanged(newImageSrc);
            setLoadImage(true);
          };
        }
      }();

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      _ref$imageSrcProp = _ref.imageSrcProp,
      imageSrcProp = _ref$imageSrcProp === void 0 ? '' : _ref$imageSrcProp,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? '#1e88e5' : _ref$color,
      _ref$imageChanged = _ref.imageChanged,
      imageChanged = _ref$imageChanged === void 0 ? function () {} : _ref$imageChanged;

  var _useState = React.useState({
    quality: 92,
    maxHeight: 1000,
    maxWidth: 1000,
    cropHeight: 150,
    cropWidth: 150,
    maintainAspectRatio: true,
    format: 'jpeg',
    arrayCopiedImages: [],
    originImageSrc: ''
  }),
      state = _useState[0],
      setState = _useState[1];

  var _useState2 = React.useState(''),
      imageSrc = _useState2[0],
      setImageSrc = _useState2[1];

  var _useState3 = React.useState(false),
      loadImage = _useState3[0],
      setLoadImage = _useState3[1];

  var _useState4 = React.useState(false),
      showEditPanel = _useState4[0],
      setShowEditPanel = _useState4[1];

  var _useState5 = React.useState(labelEn),
      labels = _useState5[0],
      setLabels = _useState5[1];

  var _useState6 = React.useState(initialConfig),
      configuration = _useState6[0],
      setConfiguration = _useState6[1];

  var imagePicker = React.useRef(null);
  var fileType = React.useRef('');
  var urlImage = React.useRef('');
  var uuidFilePicker = Date.now().toString(20);
  var imageName = React.useRef('donload');
  React.useEffect(function () {
    appendLinkIconsToHead();
    processConfig();
  }, [config]);
  React.useEffect(function () {
    (function () {
      try {
        var _temp2 = function () {
          if (imageSrcProp) {
            return Promise.resolve(parseToBase64(imageSrcProp)).then(function (result) {
              var newState = result.state;
              newState.originImageSrc = imageSrcProp;
              newState.arrayCopiedImages.push({
                lastImage: result.imageUri,
                width: newState.maxWidth,
                height: newState.maxHeight,
                quality: newState.quality,
                format: newState.format,
                originImageSrc: imageSrcProp
              });
              setImageSrc(result.imageUri);
              setState(newState);
              setLoadImage(true);
            });
          } else {
            var newState = _extends({}, state);

            newState.originImageSrc = null;
            newState.arrayCopiedImages = [];
            newState = _extends({}, newState, {
              format: 'jpeg',
              maxHeight: 1000,
              maxWidth: 1000,
              cropHeight: 150,
              cropWidth: 150,
              maintainAspectRatio: true,
              basicFilters: undefined
            });
            setLoadImage(false);
            setImageSrc(null);
            setState(newState);
          }
        }();

        return _temp2 && _temp2.then ? _temp2.then(function () {}) : void 0;
      } catch (e) {
        Promise.reject(e);
      }
    })();
  }, [imageSrcProp]);

  function processConfig() {
    var dataConf = _extends({}, configuration, config);

    setConfiguration(dataConf);

    if (config.language != undefined) {
      if (config.language == 'en') {
        setLabels(_extends({}, labelEn));
      }

      if (config.language == 'es') {
        setLabels(_extends({}, labelEs));
      }

      if (config.language == 'fr') {
        setLabels(_extends({}, labelFr));
      }

      if (config.language == 'de') {
        setLabels(_extends({}, labelDe));
      }
    }
  }

  function appendLinkIconsToHead() {
    var head = document.head;
    var linkIcons = head.querySelector('#ngp-image-picker-icons-id');
    if (linkIcons) return;
    var link = document.createElement('link');
    link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
    link.rel = 'stylesheet';
    link.id = 'ngp-image-picker-icons-id';
    head.appendChild(link);
  }

  function onUpload(event) {
    var _imagePicker$current;

    event.preventDefault();
    imagePicker === null || imagePicker === void 0 ? void 0 : (_imagePicker$current = imagePicker.current) === null || _imagePicker$current === void 0 ? void 0 : _imagePicker$current.click();
  }

  function handleFileSelect(event) {
    var _event$target;

    var files = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.files;

    if (files) {
      var file = files[0];
      imageName.current = file.name.split('.')[0];
      fileType.current = file.type;
      if (!fileType.current.includes('image')) return;
      urlImage.current = "data:" + file.type + ";base64,";

      if (file) {
        setState(_extends({}, state, {
          format: fileType.current.split('image/')[1]
        }));
        var reader = new FileReader();
        reader.onload = handleReaderLoaded.bind(this);
        reader.readAsBinaryString(file);
      }
    }
  }

  var sizeImage = React.useMemo(function () {
    if (imageSrc && imageSrc.length) {
      return Math.ceil(3 / 4 * imageSrc.length / 1024);
    } else {
      return '';
    }
  }, [imageSrc]);

  function parseToBase64(imageUrl) {
    var newState = _extends({}, state);

    var types = imageUrl.split('.');
    var type = types[types.length - 1];

    if (type && (type == 'png' || type == 'jpeg' || type == 'webp')) {
      type = type;
    } else {
      type = 'jpeg';
    }

    newState.format = type;
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.crossOrigin = 'Anonymous';
      newState.maxHeight = img.height;
      newState.maxWidth = img.width;

      img.onload = function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var ratio = 1.0;
        canvas.width = img.width * ratio;
        canvas.height = img.height * ratio;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        var dataURI = canvas.toDataURL("image/" + type, newState.quality);
        return resolve({
          dataUri: dataURI,
          width: canvas.width,
          height: canvas.height
        });
      };

      img.onerror = function (e) {
        return reject(e.message || "Error loading the src = " + imageUrl);
      };

      img.src = imageUrl;
    }).then(function (data) {
      newState = _extends({}, newState, {
        maxHeight: data.height,
        maxWidth: data.width
      });
      return {
        imageUri: data.dataUri,
        state: newState
      };
    });
  }

  function onOpenEditPanel() {
    setShowEditPanel(true);
  }

  function onCloseEditPanel(data) {
    setShowEditPanel(false);

    if (data) {
      setState(data.state);
      setImageSrc(data.imageSrc);
      imageChanged(data.imageSrc);
    }
  }

  function onRemove() {
    setImageSrc(null);
    setLoadImage(false);
    imageChanged(null);

    var newState = _extends({}, state, {
      originImageSrc: '',
      format: 'jpeg',
      maxHeight: 1000,
      maxWidth: 1000,
      cropHeight: 150,
      cropWidth: 150,
      maintainAspectRatio: true,
      arrayCopiedImages: [],
      basicFilters: undefined,
      quality: 92
    });

    setState(newState);
    setShowEditPanel(false);
  }

  return React__default.createElement("div", {
    className: "ReactImagePickerEditor"
  }, !loadImage && React__default.createElement("div", {
    className: "place-image"
  }, React__default.createElement("div", {
    className: "image-holder",
    style: {
      width: configuration.width,
      height: configuration.height,
      borderRadius: configuration.borderRadius,
      aspectRatio: configuration.aspectRatio + ''
    }
  }, React__default.createElement("button", {
    title: labels['Upload a image'],
    className: "icon-btn image-upload-btn",
    onClick: onUpload
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "add_a_photo")), React__default.createElement("input", {
    ref: imagePicker,
    type: "file",
    style: {
      "display": "none"
    },
    id: 'filePicker-' + uuidFilePicker,
    onChange: handleFileSelect
  }))), loadImage && React__default.createElement("div", {
    className: "place-image"
  }, React__default.createElement("div", {
    className: "image-holder-loaded",
    style: {
      width: configuration.width,
      height: configuration.height,
      borderRadius: configuration.borderRadius,
      aspectRatio: configuration.aspectRatio + ''
    }
  }, React__default.createElement("img", {
    src: imageSrc,
    alt: "image-loaded",
    style: {
      borderRadius: configuration.borderRadius,
      objectFit: configuration.objectFit
    }
  }), React__default.createElement("div", {
    className: "curtain",
    onClick: onUpload
  }, React__default.createElement("button", {
    title: labels['Upload a image']
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "add_a_photo"))), React__default.createElement("input", {
    ref: imagePicker,
    type: "file",
    style: {
      "display": "none"
    },
    id: 'filePicker-' + uuidFilePicker,
    onChange: handleFileSelect
  })), sizeImage && React__default.createElement("p", {
    className: "caption image-caption",
    style: {
      color: sizeImage > 120 ? '#f44336' : 'unset',
      fontWeight: sizeImage > 120 ? '500' : 'unset'
    }
  }, "size: ", sizeImage, "Kb \xA0 ", state.format), React__default.createElement("div", {
    style: {
      flexDirection: 'row',
      'boxSizing': 'border-box',
      display: 'flex',
      'placeContent': 'flex-start',
      'alignItems': 'flex-start'
    },
    className: "editing-bar-btn"
  }, !configuration.hideAddBtn && React__default.createElement("button", {
    className: "icon-btn",
    id: "upload-img",
    title: labels['Upload a image'],
    onClick: onUpload
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "add_a_photo")), !configuration.hideEditBtn && React__default.createElement("button", {
    className: "icon-btn",
    id: "edit-img",
    title: labels['Open the editor panel'],
    onClick: onOpenEditPanel
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "edit")), !configuration.hideDownloadBtn && React__default.createElement("a", {
    id: "download-img",
    title: labels['Download the image'],
    href: imageSrc,
    download: imageName.current
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "cloud_download")), !configuration.hideDeleteBtn && React__default.createElement("button", {
    className: "icon-btn",
    id: "delete-img",
    title: labels['Remove'],
    onClick: function onClick() {
      return onRemove();
    }
  }, React__default.createElement("span", {
    className: "material-icons"
  }, "delete")))), showEditPanel && React__default.createElement(EditImage, {
    saveUpdates: onCloseEditPanel,
    labels: labels,
    color: color,
    image: imageSrc,
    initialState: state
  }));
});

module.exports = ReactImagePickerEditor;
//# sourceMappingURL=index.js.map
